mod!doc = @'
Utilities, simple functions
@'

@doc'
Prints msg to stderr and exits with exit_code
- msg : Message to print
- [exit_code], Int : Program output
@'
fn fatal(msg, exit_code: -1) {
    # TODO : Print to stderr
    print msg

    exit(exit_code)
}

# --- Default functions ---
# - Size -
# Used to avoid boilerplate code
@doc'
Returns whether it is empty
- return, Bool
@'
fn default_collection_empty() {
    return len(me) == 0
}

@doc'
Returns whether it is not empty

- return, Bool
@'
fn default_collection_not_empty() {
    return len(me) != 0
}

# - Searching -
@doc'
Returns the index of the first occurence of item.
Returns -1 if not found.

- item : Item to find
- return : The index of the item (or -1 if not found)
@'
fn default_collection_index(item) {
    i = 0
    for e in me {
        if e == item {
            return i
        }

        i += 1
    }

    return -1
}

@doc'
Returns the index of the last occurence of item.
Returns -1 if not found.

- item : Item to find
- return : The index of the item (or -1 if not found)
@'
fn default_collection_last_index(item) {
    for i in len(me) - 1 ->= 0 .. -1 {
        if me[i] == item {
            return i
        }
    }

    return -1
}

@doc'
Returns the index of item in a sorted collection using
the binary search algorithm.
Returns -1 if not found.

- item : Item to find
- return : The index of the item (or -1 if not found)
@'
fn default_collection_bin_search(item) {
    l = 0
    r = len(me) - 1
    while l <= r {
        # TODO C : Int div
        mid = l + Int((r - l) / 2)

        if me[mid] > item {
            r = mid - 1
        } elif me[mid] < item {
            l = mid + 1
        } else {
            return mid
        }
    }

    return -1
}

# - Functional -
@doc'
Applies f to every item of the collection

- f : Functor
@'
fn default_collection_for_each(f) {
    for i in me {
        f(i)
    }
}

@doc'
Returns a collection with all values mapped
by f

- f : Functor
- [init] : The collection to use
@'
fn default_collection_map(f, init: []) {
    result = init

    for i in 0 -> len(me) {
        result.add(f(me[i]))
    }

    return result
}

@doc'
Returns a collection with all values that
matches the predicate f

- f : Predicate
- [init] : The collection to use
@'
fn default_collection_filter(f, init: []) {
    result = init

    for i in 0 -> len(me) {
        if f(me[i]) {
            result.add(me[i])
        }
    }

    return result
}

@doc'
Returns the cumulative application of f
to all elements starting by (init, first element)

- f : Functor of 2 parameters
- [init] : The collection to use
@'
fn default_collection_reduce(f, init: null) {
    result = init

    for i in 0 -> len(me) {
        result = f(result, me[i])
    }

    return result
}

@doc'
Sorts the collection inplace

- [cmp] : Custom compare, returns a <=> b, by default a@cmp is used
- return : Returns col
@'
fn default_collection_sort(cmp: null) {
    if cmp is Null {
        return sort(me)
    } else {
        return sort(me, cmp)
    }
}

# --- Defaults ---
@doc'
Sets up the collection type with default collection methods
and attribute variables.
@'
fn set_default_collection(type, is_random_access: false) {
    # Size
    type.empty = copy(default_collection_empty)
    type.empty!name = typename(type) + '.empty'

    type.not_empty = copy(default_collection_not_empty)
    type.not_empty!name = typename(type) + '.not_empty'

    # Searching
    type.index = copy(default_collection_index)
    type.index!name = typename(type) + '.index'

    type.last_index = copy(default_collection_last_index)
    type.last_index!name = typename(type) + '.last_index'

    if is_random_access {
        type.bin_search = copy(default_collection_bin_search)
        type.bin_search!name = typename(type) + '.bin_search'
    }

    # Functional
    type.for_each = copy(default_collection_for_each)
    type.for_each!name = typename(type) + '.for_each'

    type.map = copy(default_collection_map)
    type.map!name = typename(type) + '.map'

    type.filter = copy(default_collection_filter)
    type.filter!name = typename(type) + '.filter'

    type.reduce = copy(default_collection_reduce)
    type.reduce!name = typename(type) + '.reduce'

    if is_random_access {
        type.sort = copy(default_collection_sort)
        type.sort!name = typename(type) + '.sort'
    }
}
